# DataBase

参考连接：
[CS-Notes/数据库系统原理 -- GitHub](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md)
[史上最全的数据库面试题](https://www.cnblogs.com/wenxiaofei/p/9853682.html)
[Waking-UP 数据库](https://github.com/wolverinn/Waking-Up/blob/master/Database.md)

---

## 数据库基础概念

### 事务的概念和特性

概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。是满足ACID特性的的一组操作

#### ACID特性

##### 1. 原子性（Atomicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

##### 2. 一致性（Consistency）

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

##### 3. 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

##### 4. 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

---

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

* 只有满足一致性，事务的执行结果才是正确的。
* 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
* 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
* 事务满足持久化是为了能应对系统崩溃的情况。
  
##### AUTOCOMMIT

---
MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。


### 并发一致性问题

---
在并发环境下，事务的隔离性很难保证，因此会出现并发一致性问题

以下描述中，事务用字母T表示

#### 丢失修改

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

#### 读脏数据

T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

#### 不可重复读

T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

#### 幻影读

T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）

---
产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。


### 封锁

---

#### 封锁粒度

MySQL中有两种封锁粒度

#### 封锁类型

##### 1. 读写锁

* 互斥锁（Exclusive），简写为 X 锁，又称写锁。
* 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
* 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

##### 2.意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

关于锁的兼容关系解释：

* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

#### 封锁协议

---

#### 三级封锁协议

**一级封锁协议**

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

**二级封锁协议**

在一级的基础上，要求读取数据A是必须加S锁，读取完马上释放S锁

可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据一级封锁协议，会加X锁，那么就不能加S锁了，也就是不会读入数据

**三级封锁协议**

在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁

可以解决不可重复读的问题，因为读A时，其他事务不能对A加X锁，从而避免了在读期间发生数据改变

#### 两段锁协议

加锁和解锁分为两个阶段进行

**可串行化调度**是指：通过并发控制，使得并发的事务与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题

事务遵循两段锁协议时保证可串行化调度的充分条件。

### 隔离级别

---

#### 未提交读（READ UNCOMMITTED）

在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读

#### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可避免脏读问题；

#### 可重复度（REPEATABLE READ）

可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读

#### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行

### 多版本并发控制（MVCC）

多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。

* 创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；
* 删除版本号：删除操作时的事务版本号；
* 各种操作：
  
    * 插入操作时，记录创建版本号；
    * 删除操作时，记录删除版本号；
    * 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    * 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC

#### 快照读与当前读

##### 快照读

MVCC 的select 操作时快照中的数据，不需要进行加锁操作

```mysql
SELECT * FROM table ...;
```

##### 当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

### 数据库范式

可以具体见课本

#### 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

#### 异常的产生

不符合范式的关系，会产生很多异常，主要有以下四种异常

* 冗余数据：数据会冗余出现
* 修改异常：修改一个记录中的信息，但是另一个记录中相同的信息却没有被修改
* 删除异常：删除一个信息，那么也丢失其他信息。
* 插入异常：
  
#### 范式

##### 第一范式

属性不可分

##### 第二范式

每一个非主属性完全函数依赖于码

##### 第三范式

非主属性不传递函数依赖于键码。

### 几种表的连接方式

#### 内连接（inner join）

仅将两个表中满足连接条件的行组合起来作为结果集

* 自然连接： 只考虑属性相同的元组对
* 等值连接： 给定条件进行查询

#### 外连接（outer join）

* 左连接：左边表中的所有数据都有显示出来，右边的表数据志显示共有的那部分，没有对应的部分补null
* 右连接： 和左连接相反
* 全外连接：查询出左表和右表所有数据，但是去除两表的重复数据

#### 交叉连接（cross join）
 
* 返回两表的笛卡儿积

### 存储过程以及其优缺点

存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。

优点：

* 预先编译，而不需要每次运行时编译，提高了数据库执行**效率**；
* 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以**减少网络通信量**；
* 具有**可复用性**，减少了数据库开发的工作量；
* **安全性高**，可以让没有权限的用户通过存储过程间接操作数据库；
* 更**易于维护**


缺点：

* **可移植性差**，存储过程将应用程序绑定到了数据库上；
* **开发调试复杂**：没有好的IDE；
* **修改复杂**，需要重新编译，有时还需要更新程序中的代码以更新调用

### Drop/Delete/Truncate的区别

* Delete用来删除表的全部或者**部分数据**，执行delete之后，用户需要**提交之后**才会执行，会触发表上的DELETE**触发器**（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；
* Truncate删除表中的所有数据，这个操作**不能回滚**，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
* Drop命令从数据库中**删除表**，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；

#### 触发器

触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于**保证数据完整性**（比如可以检验或转换数据）。


### 视图和游标

* **视图**：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。特别地，对视图的修改不影响基本表。好处：
    * 通过只给用户访问视图的权限，保证数据的安全性；
    * 简化复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；
* **游标（Cursor）**：用于定位在查询返回的结果集的特定行，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。


### 数据库索引

***索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。***索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。

#### 索引实现的原理

使用B+树来实现

###### 使用B树和B+树的比较

InnoDB的索引使用的时B+树，B+树对比B树的优点有：

* IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；
* 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
* 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

##### 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？

* B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；

* B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

* 数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

##### 文件索引和数据库索引为什么使用B+树?

　　文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。


###### 使用B树索引和哈希索引的比较

哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。

#### 使用索引的优点

* 大大加快了数据的检索速度；
* 可以显著减少查询中分组和排序的时间；
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
* 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）
  
缺点： 建立和维护索引会耗费一定的时间和空间，更新索引很慢

#### 索引失效

* 以“%(表示任意0个或多个字符)”开头的LIKE语句；
* OR语句前后没有同时使用索引；
* 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
* 对于多列索引，必须满足 最左匹配原则/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
* 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

#### 适合做索引的情况

* 某列经常作为最大最小值；
* 经常被查询的字段；
* 经常用作表连接的字段；
* 经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段

##### 创建索引时应该注意

* 只应建立在小字段上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；
* 建立索引的字段应该非空，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；
* 选择数据密度大（唯一值占总数的百分比很大）的字段作索引

#### 索引的分类

* **普通索引**
* **唯一索引 UNIQUE**：索引列的值必须唯一，但允许有空值；
* **主键索引 PRIMARY KEY**：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；
* **单列索引和多列索引/复合索引（Composite）**：索引的列数；
* **覆盖（Covering）索引**：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
* **聚集（Clustered）索引/非聚集索引**：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；

* **虚拟索引（Virtual）**：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用

### 数据库的优化

#### SQL语句的优化

* 尽量避免在where子句中使用!=,<,>操作符或者对字段进行null置判断，否则引擎将会放弃使用索引而全表扫描
* 只返回必要的列，尽量减少select * 这样的语句
* 只返回必要的行
* 将大连接查询分解，分解成对每一个表的单表查询，然后在应用程序中进行关联

#### 索引优化

尽量减少引起索引失效的情况，在合适的地方建立索引，多使用索引

#### 数据库表结构的优化

* 设计表的结构时，符合三大范式，减异常出现的可能性
* 选择合适的数据类型，减少null字段的存储，使用简单的数据类型
* 表的水平切分：将同一个表中的记录拆分到多个结构相同的表中（可以通过哈希取模或者根据ID范围来分）。这样能将数据分布到集群的不同节点上
* 表的垂直切分：将一张表按列分成多个表。
  
#### 系统配置的优化

增加TCP支持的队列数量，增加MySQL的缓存池大小和个数
提升硬件配置

## 待补充

Redis相关内容（本人暂时没用过）
[CyC2018-redis.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
[Redis常见面试题](cnblogs.com/jasontec/p/9699242.html)
[几率大的Redis面试题（含答案）](https://blog.csdn.net/Butterfly_resting/article/details/89668661)
hive相关内容

[Hive面试题（一）](https://blog.csdn.net/qq_36174081/article/details/89945050)
[HIVE基础知识及优化（面试必备）](https://blog.csdn.net/u011331430/article/details/79038103?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
